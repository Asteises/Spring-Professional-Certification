# Подготовка к Spring Professional Certification

Что такое внедрение зависимостей(DI) и в чем его преимущества?
---
Внедрение зависимостей — это специальный паттерн, который уменьшает связь между Spring компонентами. Таким образом, при применении DI, ваш код становится чище, проще, его становится легче понять и тестировать. 
Согласно паттерну DI, создание объектов для зависимостей переходит на фабрику или отдается третьей стороне. Это означает, что мы можем сосредоточиться на использовании этих объектов вместо их создания.

Преимущества DI
---

+ Уменьшенная связь между частями приложения
+ Улучшенное тестирование
+ Улучшенная архитектура приложения
+ Уменьшает шаблонный код
+ Стандартизирует разработку приложения

Почему для создания Spring beans рекомендуются интерфейсы?
---

+ Улучшенное тестирование. В тестах бин может быть заменен специальным объектом(mock или stub), который реализует интерфейс бина.
+ Позволяет использовать механизм динамических прокси из JDK(например, при создании репозитория через Spring Data)
+ Позволяет скрывать реализацию

Что такое application context?
---

В Spring Framework интерфейс org.springframework.factory.BeanFactory предоставляет фабрику для бинов, которая в то же время является IoC контейнером приложения. Управление бинами основано на конфигурации(java или xml).

Интерфейс org.springframework.context.ApplicationContext — это обертка над bean factory, предоставляющая некоторые дополнительные возможности, например AOP, транзакции, безопасность, i18n, и т.п.

Что такое контейнер и какой у него жизненный цикл?
---

Основа Spring Framework — контейнер, и наши объекты "живут" в этом контейнере.
Контейнер обычно создает множество объектов на основе их конфигураций и управляет их жизненным циклом от создания объекта до уничтожения.

Контейнер — это объект, реализующий интерфейс ApplicationContext.

Жизненный цикл контейнера
---

+ Контейнер создается при запуске приложения
+ Контейнер считывает конфигурационные данные
+ Из конфигурационных данных создается описание бинов
+ BeanFactoryPostProcessors обрабатывают описание бина
+ Контейнер создает бины используя их описание
+ Бины инициализируются — значения свойств и зависимости внедряются в бин
+ BeanPostProcessor запускают методы обратного вызова(callback methods)
+ Приложение запущено и работает
+ Инициализируется закрытие приложения
+ Контейнер закрывается
+ Вызываются callback methods

Как создать экземпляр ApplicationContext?
---

Spring обеспечивает несколько разновидностей контекста. 


Есть несколько основных реализаций интерфейса ApplicationContext:
+ FileSystemXmlApplicationContext
+ ClassPathXmlApplicationContext
+ AnnotationConfigApplicationContext
+ XmlWebApplicationContext
+ AnnotationConfigWebApplicationContext



Примеры создания контекста:
```
ApplicationContext ctx = new FileSystemXmlApplicationContext(
                                     "c:/bean_properties.xml");
                                     
ApplicationContext ctx = new AnnotationConfigApplicationContext(
                            "com.springdemoapp.JavaConfig.class");
```                            
Можете ли вы описать жизненный цикл бина в контейнере?
---

+ Загрузка описаний бинов, создание графа зависимостей(между бинами)
+ Создание и запуск BeanFactoryPostProcessors
+ Создание бинов
+ Spring внедряет значения и зависимости в свойства бина
+ Если бин реализует метод setBeanName() из интерфейса NameBeanAware, то ID бина передается в метод
+ Если бин реализует BeanFactoryAware, то Spring устанавливает ссылку на bean factory через setBeanFactory() из этого интерфейса.
+ Если бин реализует интерфейс ApplicationContextAware, то Spring устанавливает ссылку на ApplicationContext через setApplicationContext().
+ BeanPostProcessor это специальный интерфейс(о нем ниже), и Spring позволяет бинам имплементировать этот интерфейс. Реализуя метод postProcessBeforeInitialization(), можно изменить экземпляр бина перед его(бина) инициализацией(установка свойств и т.п.)
+ Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный @PostConstruct или метод initMethod из аннотации @Bean.
+ Теперь бин готов к использованию. Его можно получить с помощью метода ApplicationContext#getBean().
+ После того как контекст будет закрыт(метод close() из ApplicationContext), бин уничтожается.
+ Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy(), чтобы очистить ресурсы или убить процессы в приложении. Если в аннотации @Bean определен метод destroyMethod, то вызовется и он.

![kxat5ery0dcq_sujzijmiqyutda](https://user-images.githubusercontent.com/94966002/208645939-13cecae9-688d-4c9e-9241-bc74f332053e.png)

Как получить ApplicationContext в интеграционном тесте?
---

Если вы используете JUnit 5, то вам нужно указать 2 аннотации:

+ @ExtendWith(TestClass.class) — используется для указания тестового класса
+ @ContextConfoguration(classes = JavaConfig.class) — загружает java/xml конфигурацию для создания контекста в тесте

Можно использовать аннотацию @SpringJUnitConfig, которая сочетает обе эти аннотации.
Для теста веб-слоя можно использовать аннотацию @SpringJUnitWebConfig.

Как завершить работу контекста в приложении?
---

Если это не веб-приложение, то есть 2 способа:

+ Регистрация shutdown-hook с помощью вызова метода registerShutdownHook(), он также реализован в классе AbstractApplicationContext. Это предпочтительный способ.
+ Можно вызвать метод close() из класса AbstractApplicationContext.

В Spring Boot приложении:

+ Spring Boot самостоятельно зарегистрирует shutdown-hook за вас.

Что такое Java-конфигурация? Как она применяется?
---

Чтобы создать класс с конфигурацией на основе Java-кода, нужно аннотировать его с помощью
@Configuration. 

Этот класс будет содержать фабричные методы для создания бинов в контейнере.

Эти методы должны быть аннотированы аннотацией @Bean.


Пример:

```@Configuration
public class DSConfig {
  @Bean
  public DataSource dataSource() {
      return DataSourceBuilder
          .create()
          .username("")
          .password("")
          .url("")
          .driverClassName("")
          .build();
  }
}
```

Этот класс поместит в контейнер экземпляр класса DataSource. Позднее его можно будет использовать при доступе к базе данных.

DI используя аннотации, сканирование классов
---

Component scanning(сканирование компонентов) — Spring автоматически обнаруживает бины, которые будут находиться в контейнере. Это бины с аннотациями-стереотипами.

Однако сканирование компонентов не включено по умолчанию.

Чтобы включить сканирование, аннотируйте @Configuration-класс аннотацией @ComponentScanning. Spring будет автоматически сканировать тот пакет, в котором находится этот класс и все его подпакеты.

Можно указать и другие пакеты для сканирования, и даже классы:
```
//сканирует 2 пакета
@Configuration(basePackages = {"soundsystem", "video"})
```

```
//сканирует класс
@Configuration(basePackageClasses = "MyClass.class")
```

Autowiring(внедрение) — Spring автоматически внедрит зависимости во время сканирования или помещения бина в контейнер.

Для внедрения зависимостей используется аннотация @Autowire.

Что такое stereotypes(аннотации-стереотипы)?
---

Стереотипы — это аннотации, обозначающие специальную функциональность.
Все стереотипы включают в себя аннотацию @Component.

| Аннотация | Расшифровка |
| --- | ---| 
| @Component | Корневая аннотация, которая помечает класс как кандидат для автовнедрения |
| @Controller | Указывает, что класс является контроллером для отправления данных на фронт |
| @RestController | Указывает, что класс является контроллером для REST. Содержит аннотации Controller и @ResponseBody |
| @Service | Указывает, что класс является сервисом для выполнения бизнес-логики |
| @Repository | Указывает, что класс является репозиторием для работы с бд |
| @Configuration | Указывает, что класс содержит Java-конфигурацию(@Bean-методы) |

Какие существуют области видимости у бинов? Какая у них видимость по умолчанию?
---

Область видимости — scope, скоуп. Существует 2 области видимости по умолчанию.

+ Singleton - Область видимости по умолчанию. В контейнере находится всего 1 экземпляр бина
+ Prototype - В контейнере может находится любое количество экземпляров бина


И 4 области видимости в веб-приложении.

+ Request - Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин
+ Session - Область видимости — 1 сессия. На каждую сессию создается новый бин
+ Application - Область видимости — жизненный цикл ServletContext
+ WebSocket - Область видимости — жизненный цикл WebSocket
